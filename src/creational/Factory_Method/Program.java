package creational.Factory_Method;

public class Program {
    public static void main(String[] args) {
        DeveloperFactory developerFactory = createDeveloperBySpecialty("c++");
        Developer developer = developerFactory.createDeveloper();

        developer.writeCode();
    }
    static DeveloperFactory createDeveloperBySpecialty(String specialty) {
        if (specialty.equalsIgnoreCase("java")) {
            return new JavaDeveloperFactory();
        } else if (specialty.equalsIgnoreCase("C++")) {
            return new CppDeveloperFactory();
        } else if (specialty.equalsIgnoreCase("php")) {
            return new PhpDeveloperFactory();
        } else {
            throw new RuntimeException(specialty + " is unknown specialty");
        }
    }
}
//метод createDeveloper и есть наш паттерн

// Вкратце: паттерн "фабричный метод" предлагает создавать объекты не напрямую (т. е. не используя оператор new), а через вызов особого фабричного метода в котором произойдет создание Объекта при помощи new, но делать это будет фабричный метод (иногда это бывает полезно).

//паттерн Factory Method - порождающий шаблон проектирования, определяет стандартный метод создания объекта,
// не связанный с вызовом конструктора, оставляя решение о том, какой именно объект создавать, за подклассами.

//Шаблон: Абстрактная фабрика (Abstract Factory)
//        =======================================================================================================
//        Цель:
//
//        Создание интерфейса, для создания множества взаимосвязанных или взаимозависимых объектов, без жёсткой
//        привязке к конкретным классам.
//
//        =======================================================================================================
//
//        Для чего используется:
//
//        Для создания множеств взаимосвязанных объектов.
//
//        =======================================================================================================
//        Пример использования:
//
//        - система не должна зависеть от метода создания, компоновки и представления входящих в неё объектов;
//        - входящие взаимосвязанные объекты должны использоваться вместе;
//        - система должна конфигурироваться одним из множеств объектов, из которых она состоит;
//        - нам необходимо предоставить множество объектов, раскрывая только их интерфейсы но не реализацию.
//
//        =======================================================================================================