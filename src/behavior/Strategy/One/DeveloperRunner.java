package behavior.Strategy.One;

public class DeveloperRunner {
    public static void main(String[] args) {

        //executeActivity == выполнить действие

        Developer developer = new Developer();

        developer.setActivity(new Sleeping());
        developer.executeActivity();

        developer.setActivity(new Training());
        developer.executeActivity();

        developer.setActivity(new Coding());
        developer.executeActivity();

        developer.setActivity(new Reading());
        developer.executeActivity();

        developer.setActivity(new Sleeping());
        developer.executeActivity();
    }
}
//Шаблон проектирования "Стратегия" предназначен для определения группы классов, которые представляют собой набор возможных вариантов поведения.
// Это дает возможность гибко подключать те или иные наборы вариантов поведения во время работы приложения, меняя его функциональность "на ходу".

//в State переход между состояниями происходит внутри состояний или внутри контекста

//в Strategy мы переходим между состояниями ТОЛЬКО вызывая метод setStrategy в методе main

//Еще аналогия для тех кто играл в Скайрим или подобные игры )) должно стать понятно отличие Стратегии от Состояния
//Когда вы даете персонажу разное оружие - вы переключаете стратегию. Например: одноручный меч (определенная анимация, скорость атаки), берем в руки двуручную кувалду - анимация ударов меняется, скорость атаки тоже. При этом вы просто жмете ту же кнопку "атаковать", но делается это по разному, в зависимости от оружия (стратегии).
//В игре есть магическое оружие, которое обладает двумя состояниями:
//1. Есть заряды душ - оно наносит дополнительный урон молнией, огнем, льдом.., соответственно меняется анимация оружия и урон.
//2. Заряды закончились - оружие просто наносит обычный урон без дополнительных эффектов, до тех пор пока его не зарядить камнем душ снова (то есть изменится его состояние).

//Шаблон: Стратегия (Strategy)

//
//Цель:
//Взаимозаменяемость семейства классов
//
//Для чего используется:
//Опредление семейства классов, инкапсулирование каждого из них и организация их взаимозаменяемости.
//
//Пример использования:
//— есть несколько родственных классов, которые отличаются поведением;
//— необходимо иметь несколько вариантов поведения;
//в классе есть данные, о которых не должен знать клиент;
//с помощью условных операторов в классе определено большое количество возможных поведений.