package behavior.Chain_of_Responsibility;

import java.util.Scanner;

import static behavior.Chain_of_Responsibility.Note.*;

public class BugTracker {
    public static void main(String[] args) {
        NoteModule note100 = new NoteModule100(R100.getNum());
        NoteModule note50 = new NoteModule50(R50.getNum());
        NoteModule note20 = new NoteModule20(R20.getNum());
        NoteModule note5 = new NoteModule5(R5.getNum());

        note100.setNextMoneyModule(note50);
        note50.setNextMoneyModule(note20);
        note20.setNextMoneyModule(note5);

        Money money = new Money();
        Scanner scanner = new Scanner(System.in);
        int i = scanner.nextInt();

        money.setAmt(i);

        note100.takeMoney(new Money(money.getAmt()));
    }
}
//шаблон Chain of Responsibility предназначен для организации в системе уровней ответственности (или обязанностей)
// и позволяет определить должно ли сообщение обрабатываться на том уровне, где оно было получено, или же оно должно передаваться для обработки другому объекту.

//Шаблон: Цепочка ответственности (Chain of Responsibility)
//
//Цель:
//Связывание объектов-получатетелей в цепочку и передача запроса по ней.
//
//Для чего используется:
//Помогает избежать привязки отправителя запроса к его получателю, что даёт возможность обработать
//данный запрос нескольким объектам.
//
//Пример использования:
//— ослабление привязанности (объект не должен знать, кто именно обработает его запрос);
//— дополнительная гибкость при распределении обязанностей между объектами;

//Шаблон Chain of Responsibility можно адаптировать к потребностям приложения
//несколькими способами. Основные подходы базируются либо на выбранных страте-
//гиях обработки, либо на стратегиях пересылки.

//Стратегии обработки (handling strategies) фокусируются на том, как реализовано
//поведение обработчика. Среди многих вариантов можно выделить следующие.

//• Используемый по умолчанию обработчик. В некоторых реализациях устанавливает-
//ся базовый обработчик, который используется всеми уровнями как обработчик
//по умолчанию. Этот подход обычно применяется только в тех случаях, когда в
//системе отсутствует явно определенный класс пересылки. Используемый по
//умолчанию обработчик особенно полезен для решения проблемы пропавших
//сообщений, упоминавшейся в приведенном выше подразделе "Достоинства и
//недостатки" данного раздела.

//• Расширение обработчика. В этом варианте обработчики, расположенные на каж-
//дом последующем уровне, добавляют свою функциональность к функциональ-
//ности базового обработчика. Например, данный вариант может оказаться по-
//лезным в таком случае, как реализация ведения журналов.

//• Динамические обработчики. В некоторых реализациях шаблона Chain of Responsibility
//разрешается изменять структуру подсистемы пересылки сообщений во время вы-
//полнения программы. Определив в каждом классе каждого уровня специальный
//метод, можно определять и модифицировать схему передачи сообщений во время
//работы приложения (естественно, со всеми последствиями, вытекающими из тако-
//го усложнения системы).